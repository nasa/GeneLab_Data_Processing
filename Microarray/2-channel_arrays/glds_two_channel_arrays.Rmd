---
title: "Two Channel Expression Microarray Processing"
author: "NASA GeneLab Project"
output: html_document
params:
  glds:
    label: "Enter GLDS Accession #"
    input: text
    value: ""
    width: "400"
  organism:
    label: "Select Organism"
    input: select
    choices: ["Homo sapiens","Mus musculus","Rattus norvegicus","Danio rerio","Drosophila melanogaster","Caenorhabditis elegans","Saccharomyces cerevisiae","Arabidopsis thaliana","Escherichia coli","Bacillus subtilis"]
    width: "400"
    value: NA
  format:
    label: "Microarray Data Format"
    input: select
    choices: ["Agilent GenePix","Agilent",GenePix,Nimblegen,Spot,Imagene,Bluefuse,Generic]
    width: "400"
    value: NA
  background_correction:
    label: "Background Correction"
    choices: [normexp,subtract,morph]
    input: select
    width: "400"
    value: NA
  normalization_within:
    label: "Within Array Normalization"
    choices: [loess,printtiploess,robustspline]
    input: select
    width: "400"
    value: NA
  normalization_between:
    label: "Between Array Normalization"
    choices: [Aquantile,quantile]
    input: select
    width: "400"
    value: NA
  primary:
    label: "Primary Annotation Keytype"
    choices: [REFSEQ,ENSEMBL,ACCNUM,ALIAS,SYMBOL,ENTREZID,TAIR,ORF,SGD]
    input: select
    width: "400"
    value: NA
  datafiles:
    label: "Select Raw Data Files"
    input: file
    multiple: TRUE
    buttonLabel: "Browse..."
    placeholder: "No files selected"
    value: NULL
    width: "400"
  probefile:
    label: "Select Probe Annotation File"
    input: file
    multiple: FALSE
    buttonLabel: "Browse..."
    placeholder: "No file selected"
    value: NULL
    width: "400"
  isafile:
    label: "Select ISA Metadata File"
    input: file
    multiple: FALSE
    buttonLabel: "Browse..."
    placeholder: "No file selected"
    value: NULL
    width: "400"

---

```{r setup, include=FALSE}
options(shiny.maxRequestSize=50*1024^2)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
try({
  if (length(params$datafiles$name) == 1){
    params$datafiles$name <- tools::list_files_with_exts(dir = dir(params$datafiles$datapath[1]), exts = tools::file_ext(params$datafiles$datapath[1]), full.names = FALSE)
    params$datafiles$datapath <- tools::list_files_with_exts(dir = dir(params$datafiles$datapath[1]), exts = tools::file_ext(params$datafiles$datapath[1]), full.names = TRUE)
  }
})

```



```{r eval=FALSE, include=FALSE}

### Render Parameter Selection
paramDir<-tempdir()
list.files(paramDir)

options(shiny.maxRequestSize=50*1024^2) 

x <- xfun::Rscript_call(
  rmarkdown::render,
  list(input = 'parameters.Rmd', output_format = 'html_document', params = 'ask',output_dir = paramDir, intermediates_dir = paramDir,knit_root_dir = paramDir, run_pandoc = FALSE, envir = new.env(parent = parent.frame())))
knit_meta <- attr(x, "knit_meta")
list.files(paramDir)

```

```{r manual_entry}
### Set Parameters Manually. 
### Demo dataset GLDS-8 included

workdir <- file.path(getwd())
which_assay <- 1 # for studies with multiple two-channel microarrays

opt <- list()
opt$glds <-"GLDS-81"
opt$organism <- "Bacillus subtilis"
opt$format <- "Agilent"
opt$model <- "Separate Channels"
opt$background_correction <- "normexp"
opt$normalization_within <- "loess"
opt$normalization_between <- "Aquantile"
opt$primary <- "ALIAS"
opt$filter_nonexpressed <- TRUE
opt$filter_control <- TRUE
opt$filter_nonannotated <- TRUE
opt$datafiles$name <- list.files(file.path(getwd(),"demo_dataset",opt$glds,"00-RawData"),pattern = "*raw.txt",full.names = FALSE )
opt$datafiles$datapath <- list.files(file.path(getwd(),"demo_dataset",opt$glds,"00-RawData"),pattern = "raw.txt",full.names = TRUE )
opt$probefile$name <- list.files(file.path(getwd(),"demo_dataset",opt$glds,"Metadata"),pattern = "*.annot.txt",full.names = FALSE )
opt$probefile$datapath <- list.files(file.path(getwd(),"demo_dataset",opt$glds,"Metadata"),pattern = "*.annot.txt",full.names = TRUE )
opt$isafile$name <- list.files(file.path(getwd(),"demo_dataset",opt$glds,"Metadata"),pattern = "*ISA.zip",full.names = FALSE )
opt$isafile$datapath <- list.files(file.path(getwd(),"demo_dataset",opt$glds,"Metadata"),pattern = "*ISA.zip",full.names = TRUE )


```

# Options Selected
```{r message=FALSE, warning=FALSE}
### Display selected parameters
if (length(params) == 14){opt<-params}
str(opt, max.level = 1)

source("microarray_functions.R")
all_targets<-buildTargets(opt)
if (length(all_targets) == 1){
  targets <- all_targets[[1]]
}else{
  targets <- all_targets[[which_assay]]
}
opt$model <- targets$design
```



## Assay Label Group Targets
```{r echo=FALSE}



  DT::datatable(targets$t1)
```


```{r load_raw, eval=TRUE, include=FALSE}
### Import Raw data files

columns <- list(R="F635 Mean",G="F532 Mean",Rb="B635 Median",Gb="B532 Median") # use if using custom header import
other_columns <- c("Name","ID")
columns <- list(R="F635 Mean",G="F532 Mean",Rb="B635 Median",Gb="B532 Median") # use if using custom header import
other_columns <- c("Name","ID")
library(limma)
path <- dirname(opt$datafiles$datapath[1])
files_in_assay <- sapply(targets$t1$FileName,function(x) grep(x,opt$datafiles$name))
files_in_assay <- opt$datafiles$name[files_in_assay]

if (opt$format == "Agilent GenePix"){
 RG <- read.maimages(files_in_assay, source="genepix", path=path,wt.fun=wtflags(weight=0,cutoff=-50))
 }else if (opt$format == "Agilent"){
 RG <- read.maimages(files_in_assay, source="agilent", path=path)
 }else if (opt$format == "Spot"){
 RG <- read.maimages(files_in_assay, source="spot", path=path)
 }else if (opt$format == "Imagene"){
 RG <- read.maimages(files_in_assay, source="imagene", path=path)
 }else if (opt$format == "Bluefuse"){
 RG <- read.maimages(files_in_assay, source="bluefuse", path=path)
 }else if (opt$format == "Generic"){
 RG <- read.maimages(files_in_assay, source="generic", path=path)
 }else if (opt$format == "GenePix"){
 RG <- read.maimages(files_in_assay,source="genepix",path = path,wt.fun=wtflags(weight=0,cutoff=-50))
 #RG <- read.maimages(files_in_assay,path = path,source = "generic", columns = list(R="F635.Mean",G="F532.Mean",Rb="B635.Median",Gb="B532.Median"), annotation = c("Name","ID"),quote = "\"", sep = "\t")
 }else if (opt$format == "Nimblegen"){
   setwd(path)
   hybes <- targets$t1[,c(1,4,5,2,3)]
   colnames(hybes)[1]<-"SlideNumber"
   write.table(hybes,"nimblegen_targets.txt",append = FALSE,quote = FALSE,col.names = TRUE, row.names = FALSE, sep = "\t")

RG <-  Ringo::readNimblegen(hybesFile = "nimblegen_targets.txt",spotTypesFile = "spottypes.txt",path = path, headerPattern = "# software=DEVA", verbose = TRUE)
RG$printer <- list(ngrid.r=1, ngrid.c=1,
     nspot.r=nrow(RG), nspot.c=1)
 }
rm(path)
```

```{r probe_data_import, eval=FALSE, include=FALSE}
### Attempt to import probe level data if none provided

GPL <- NA # Example: "GPL9020"
ADF <- NA # Example: "A-GEOD-9020"
  if (!file.exists(opt$probefile$datapath)){  # If no
    try(GEOquery::getGEOfile(GPL,destdir = getwd(),AnnotGPL = TRUE, amount = "data"))
    try(ArrayExpress::getAE(ADF,path = getwd(),type = "adf",extract = TRUE))
    
  }
rm(GPL,ADF)
```



```{r probe_annotations, message=FALSE, warning=FALSE}
###### Import Annotation mapping table
map.ann <- read.csv(file = file.path(getwd(),"map_annotation.csv"), header = TRUE, stringsAsFactors = FALSE)



###### Build annotation table from GPL file if chosen
if (grepl("\\.soft$", opt$probefile$name) || grepl("\\.gpl.txt$", opt$probefile$name)){
  try({
      probedata<- GEOquery:::parseGPL(opt$probefile$datapath)
      #probedata <- GEOquery::getGEO(GEO = NULL,filename = opt$probefile$datapath,AnnotGPL = TRUE)
      probedata<- probedata@dataTable@table
      # probedata <- Biobase::read.AnnotatedDataFrame(opt$probefile$datapath, sep = "\t", header = TRUE, fill = TRUE, quote = "", stringsAsFactors = FALSE, varMetadata.char="#") 
      # probedata <- probedata@data
      # probedata <-apply(probedata,2,function(x) gsub("<[^>]+>", "",x)) # remove any HTML tags
      # probedata <-as.data.frame(apply(probedata,2,function(x)gsub('\\s+', '',x))) # remove trailing whitespace
    #probedata <- read.table(opt$probefile$datapath,sep = "\t", header = TRUE, fill = TRUE)
      # for(index in which(map.ann$SOURCE == "GPL")){ 
      #   fields <- strsplit(map.ann[index, "ANNOTATIONS"],";")[[1]]
      #   glds_header <- map.ann[index,"GLDS_ANNOTATION"]
      #   for(key in fields){
      #     if (key %in% colnames(probedata)){
      #       
      #       colnames(probedata[key])<- glds_header
      #       break
      #     }
      #   }
      # }
      probedata <- probedata[with(probedata, order(ROW,COL)),] # sort by row & col to match RG order
      probedata <- probedata@data
      RG$genes <- dplyr::left_join(RG$genes,probedata,by = c("GeneName" = "ORF"))
      #rm(fields,glds_header,index,key)
  })
} 

###### Build annotation table from ADF file if chosen
if (grepl("\\.adf.txt$", opt$probefile$name)){
probedata<- ArrayExpress:::readFeatures(opt$probefile$name, dirname(opt$probefile$datapath),ArrayExpress:::skipADFheader(opt$probefile$name, dirname(opt$probefile$datapath),proc=F))

}

if (grepl("\\.ngd$", opt$probefile$name)){
  probedata <- read.table(opt$probefile$datapath, header = TRUE, sep = "\t")
  colnames(probedata)[1:2]<- c("PROBE_ID",opt$primary)
}

try({
  RG$genes <- cbind(RG$genes,probedata[,which(!(colnames(probedata) %in% colnames(RG$genes)))])
})
rm(map.ann)
```

```{r output_files, message=FALSE, warning=FALSE, include=FALSE}

### If data imports properly, start building ouput files

dir.create(file.path(workdir,"Processed_Data"), showWarnings = FALSE)
dir.create(file.path(workdir,"Processed_Data",opt$glds), showWarnings = FALSE)
dir.create(file.path(workdir,"Processed_Data",opt$glds,"00-RawData"), showWarnings = FALSE)
path <- file.path(workdir,"Processed_Data",opt$glds,"00-RawData")
file.copy(from = opt$datafiles$datapath, to = file.path(path,opt$datafiles$name), overwrite = FALSE, recursive = FALSE, copy.mode = FALSE)
rm(path)
```

# Raw Data MA Plots
```{r rawMA, eval=exists("RG"), message=FALSE, warning=FALSE}

dir.create(file.path(workdir,"Processed_Data",opt$glds,"00-RawData","QC_Repports"), showWarnings = FALSE)
path <- file.path(workdir,"Processed_Data",opt$glds,"00-RawData","QC_Repports")
setwd(path)

for (column in 1:ncol(RG)){
 plotMD(RG, column = column, xlab = "Average log-expression", ylab = "log-fold-change", main = colnames(RG)[column])
}
printrows <- ceiling(ncol(RG)/4)
width <- 2000

png(file = "rawPlotMA.png", width = width, height = ceiling(width/4)*printrows)
par(mfrow = c(printrows,4),mar=c(5,5,5,5))
for (column in 1:ncol(RG)){
 plotMD(RG, column = column, xlab = "Average log-expression", ylab = "log-fold-change", main = colnames(RG)[column])
}
invisible(dev.off())

########## Create Array Info File
info <-opt
info[12:13]<-NULL
write.table(info,file = "arrayInfo.txt", quote = FALSE)

rm(column,path,printrows,width,info)

```

# Raw Data Density Plot
```{r raw_density, eval=exists("RG"), message=FALSE, warning=FALSE}

path <- file.path(workdir,"Processed_Data",opt$glds,"00-RawData","QC_Repports")
setwd(path)

########## Create Expression Density Plots
plotDensities(RG)
png(file = "rawDensityDistributions.png")
plotDensities(RG)
invisible(dev.off())
```

# Raw Data Box Plot
```{r raw_boxplot, eval=exists("RG"), fig.show="hold", out.width="50%", paged.print=FALSE}

path <- file.path(workdir,"Processed_Data",opt$glds,"00-RawData","QC_Repports")
setwd(path)

########## Create Raw Data Boxplot
boxplot(data.frame(log2(RG$G)),main="Green", las=2,outline=FALSE)
boxplot(data.frame(log2(RG$R)),main="Red", las=2,outline=FALSE)

png(file = "rawBoxplot.png", width = 2000, height = 2000)
par(mfrow = c(2,1),mar=c(50,5,5,5))
boxplot(data.frame(log2(RG$G)),main="Green", las=2,outline=FALSE)
boxplot(data.frame(log2(RG$R)),main="Red", las=2,outline=FALSE)
invisible(dev.off)

########## Create Checksum file
checksums <- tools::md5sum(file.path(workdir,"Processed_Data",opt$glds,"00-RawData", opt$datafiles$name))
names(checksums) <- opt$datafiles$name
write.table(checksums, "md5sum.txt",quote = FALSE)
rm(path,checksums)
```


# Array Spot Log Intensity Images
```{r images, message=FALSE, warning=FALSE, eval=exists("RG")}


########## Create Array Image Plots
dir.create(file.path(workdir,"Processed_Data",opt$glds,"00-RawData","Images"), showWarnings = FALSE)
path <- file.path(workdir,"Processed_Data",opt$glds,"00-RawData","Images")
setwd(path)

for (column in 1:ncol(RG)){
imageplot(log2(RG$Gb[,column]), RG$printer, main=colnames(RG)[column],zlim = c(1,log2(max(RG$Gb))))
  }


printrows <- ceiling(ncol(RG)/4)
width <- 2000
png(file = "images.png", width = width, height = ceiling(width/4)*printrows)
par(mfrow = c(printrows,4),mar=c(5,5,5,5))
for (column in 1:ncol(RG)){
imageplot(log2(RG$Gb[,column]), RG$printer, main=colnames(RG)[column],zlim = c(1,log2(max(RG$Gb))))
  }
invisible(dev.off())

rm(column,printrows,width,path)
```


```{r database_annotation, message=FALSE, warning=FALSE,eval=exists("RG")}


### Load organism annotation database
keytype = opt$primary
organism_table <- read.csv(file = file.path(getwd(),"organisms.csv"), header = TRUE, stringsAsFactors = FALSE)
ann.dbi <- organism_table$annotations[organism_table$species == opt$organism] # Organism specific gene annotation database
ann.dbi=as.character(ann.dbi)
if(!require(ann.dbi, character.only=TRUE)) {
  BiocManager::install(ann.dbi, ask = FALSE)
  library(ann.dbi, character.only=TRUE)
}

### Map annotations from primary keytype

try(annotation<-data.frame(ID=RG$genes$ID)) #assumes Array ID is primary annotation
try(annotation<-data.frame(ID=RG$genes$Name)) #assumes Array ID is primary annotation
try(annotation<-data.frame(ID=RG$genes$GeneName))
try(annotation<-data.frame(ID=RG$genes[,keytype]))
annotation$ID <- sub("\\.\\d+", "", annotation$ID) #remove any version suffixes from IDs



try(annotation$REFSEQ<-as.character(mapIds(eval(parse(text = ann.dbi),env=.GlobalEnv),keys = as.character(annotation$ID),keytype = keytype, column = "REFSEQ",multiVals = "first")))
try(annotation$ENSEMBL<-as.character(mapIds(eval(parse(text = ann.dbi),env=.GlobalEnv),keys = as.character(annotation$ID),keytype = keytype, column = "ENSEMBL",multiVals = "first")))
try(annotation$SYMBOL<-as.character(mapIds(eval(parse(text = ann.dbi),env=.GlobalEnv),keys = as.character(annotation$ID),keytype = keytype, column = "SYMBOL",multiVals = "first"))) #GENENAME
try(annotation$DESCRIPTION<-as.character(mapIds(eval(parse(text = ann.dbi),env=.GlobalEnv),keys = as.character(annotation$ID),keytype = keytype, column = "GENENAME",multiVals = "first"))) #DESCRIPTION
try(annotation$TAIR<-as.character(mapIds(eval(parse(text = ann.dbi),env=.GlobalEnv),keys = as.character(annotation$ID),keytype = keytype, column = "TAIR",multiVals = "first")))
try(annotation$ORF<-as.character(mapIds(eval(parse(text = ann.dbi),env=.GlobalEnv),keys = as.character(annotation$ID),keytype = keytype, column = "ORF",multiVals = "first")))
try(annotation$ENTREZID<-as.character(mapIds(eval(parse(text = ann.dbi),env=.GlobalEnv),keys = as.character(annotation$ID),keytype = keytype, column = "ENTREZID",multiVals = "first")))
try(annotation$GOSLIM_ID<-as.character(mapIds(eval(parse(text = ann.dbi),env=.GlobalEnv),keys = as.character(annotation$ID),keytype = keytype, column = "GO",multiVals = "first")))



annotation <- data.frame(annotation,stringsAsFactors = FALSE)
is.na(annotation) <- annotation == "NULL"
### Map STRING annotations
try({
string_db <- STRINGdb::STRINGdb$new( version="11", species=organism_table$taxon[organism_table$species == opt$organism],score_threshold=0)
string_map<-string_db$map(annotation,"REFSEQ",removeUnmappedRows = FALSE, takeFirst = TRUE)
annotation$STRING_ID <- string_map$STRING_id
rm(string_map,string_db)
})


annotation.subset <- annotation
RG.annotated <- RG


rm(ann.dbi,keytype,organism_table)
```


```{r normalization, message=FALSE, warning=FALSE, include=FALSE,eval=exists("RG.annotated")}

### Perform background correction and normalizations of raw data
if (opt$background_correction == "normexp"){
  RG.annotated <- backgroundCorrect(RG.annotated, method="normexp", offset=50,normexp.method="saddle")
} else {
  RG.annotated <- backgroundCorrect(RG.annotated,method = opt$background_correction)
}

MA <- normalizeWithinArrays(RG.annotated, method=opt$normalization_within, weights = RG.annotated$weights)

MA <- normalizeBetweenArrays(MA, method=opt$normalization_between)

annotation_stats <- list()
annotation_stats$total_features <- dim(MA$M)[1]
MA.summarized <- MA
```


```{r probe_filter, eval=FALSE, include=FALSE}



### Filter out Control Probes


if (opt$filter_control){
  #try(MA.summarized <- MA.summarized[annotation1$CONTROL_TYPE == FALSE,])
  filter <- which(!(MA.summarized$genes$CONTROLTYPE %in% c("pos","neg")))
  MA.summarized<- MA.summarized[filter,]
  annotation.subset <- annotation.subset[filter,]
}

### Filter out non-annotated probes
if (opt$filter_nonannotated){
  try(MA.summarized <- MA.summarized[!is.na(MA.summarized$genes$ENTREZID),])
  annotation.subset <- annotation.subset[!is.na(MA.summarized$genes$ENTREZID),]
}


### For replicate probes in each sample, replace values with the average

# MA.summarized <- avereps(MA.summarized, ID = MA.summarized$genes$ID)
# annotation_stats$unique_probes <- dim(MA.summarized)[1]

# Summarise over gene names (averaging counts over transcripts)
#MA.summarized <- avereps(MA.summarized, ID = MA.summarized$genes$SYMBOL)
#annotation_stats$annotated_genes <- dim(MA.summarized)[1]


```


```{r normalized_output, message=FALSE, warning=FALSE}

##########  Write out the expression values
dir.create(file.path(workdir,"Processed_Data",opt$glds,"01-NormalizedData"), showWarnings = FALSE)
setwd(file.path(workdir,"Processed_Data",opt$glds,"01-NormalizedData"))

#annotation.subset <- dplyr::select(MA.summarized$genes, contains(c("ID")))
colnames(annotation.subset)[1]<-opt$primary
#annotation.subset <-apply(annotation.subset, 1, unlist)
expression <- as.data.frame(MA.summarized$M)
write.csv(expression,"normalized.txt",quote=FALSE, append=FALSE)

######### Write out annotated expression values

#annotation.subset <- dplyr::select(MA.summarized$genes, contains(c("ENSEMBL","ACCNUM","REFSEQ","SYMBOL","GENENAME","ENTREZID","TAIR","GOSLIM_ID","STRING_ID")))
expression <- unlist(cbind(annotation.subset,expression))

write.csv(expression,"normalized-annotated.txt",quote=FALSE, append = FALSE)

######### Write out annotated MA file
save(MA.summarized,file = "normalized-annotated.rda")

```


# Normalized Data MA Plots
```{r normMA, eval=exists("MA"), message=FALSE, warning=FALSE}
for (column in 1:ncol(MA)){
 plotMD(MA, column = column, xlab = "Average log-expression", ylab = "log-fold-change", main = colnames(MA)[column])
}
dir.create(file.path(workdir,"Processed_Data",opt$glds,"01-NormalizedData","QC_Repports"), showWarnings = FALSE)
path <- file.path(workdir,"Processed_Data",opt$glds,"01-NormalizedData","QC_Repports")
setwd(path)
printrows <- ceiling(ncol(MA)/4)
width <- 2000
png(file = "normPlotMA.png", width = width, height = ceiling(width/4)*printrows)
par(mfrow = c(printrows,4),mar=c(5,5,5,5))
for (column in 1:ncol(MA)){
 plotMD(MA, column = column, xlab = "Average log-expression", ylab = "log-fold-change", main = colnames(MA)[column])
}
invisible(dev.off())

######### Write Annotation Report File
write.table(annotation_stats,file = "annotReport.txt", quote = FALSE)


rm(column,path,printrows,width)

```

# Normalized Data Density Plot
```{r norm_density, eval=exists("MA"), message=FALSE, warning=FALSE}
########## Create Expression Density Plots
plotDensities(MA)
path <- file.path(workdir,"Processed_Data",opt$glds,"01-NormalizedData","QC_Repports")
setwd(path)
png(file = "normDensityDistributions.png")
plotDensities(MA)
invisible(dev.off())
```


# Normalized Data Box Plot
```{r norm_boxplot, eval=exists("MA"), message=FALSE, warning=FALSE}
########## Create Raw Data Boxplot
boxplot(data.frame(log2(RG.MA(MA)$G)),main="Green", las=2,outline=FALSE)
boxplot(data.frame(log2(RG.MA(MA)$R)),main="Red", las=2,outline=FALSE)

path <- file.path(workdir,"Processed_Data",opt$glds,"00-RawData","QC_Repports")
setwd(path)
png(file = "normBoxplot.png", width = 2000, height = 2000)
par(mfrow = c(2,1),mar=c(50,5,5,5))
boxplot(data.frame(log2(RG.MA(MA)$G)),main="Green", las=2,outline=FALSE)
boxplot(data.frame(log2(RG.MA(MA)$R)),main="Red", las=2,outline=FALSE)
invisible(dev.off)

rm(path)
```

# Differential Gene Expression Summary
```{r dge_model, eval=exists("MA.summarized"), message=FALSE, warning=FALSE}

### Construct Model Matrix, Define Contrasts, and Fit linear model for supported microarray configurations

setwd(file.path(workdir,"Processed_Data",opt$glds,"00-RawData","QC_Repports"))
library(statmod)
#colnames(targets$t3)[3:4]<-c("Cy3","Cy5")

if (opt$model == "Replicate Array"){
  try({

  
  uu<-uniqueTargets(targets$t2)
  uuu<-uniqueTargets(targets$t3)
  fff <- factor(targets$t3$Cy3, levels=uuu)
  # design <- model.matrix(~0+fff)
  # design[which(design == 0)] <- -1
  # colnames(design) <- uuu

  # design <- rep(0,dim(targets$t3)[1])
  # design[targets$t3$Cy3 == uuu[1]] <- 1
  # design[targets$t3$Cy3 == uuu[2]] <- -1

  #fit <- lmFit(MA.summarized, design)
  fit <- lmFit(MA.summarized, ref=uuu[1])
  contrasts<-c(paste(uuu[1],uuu[2],sep = "-"),paste(uuu[2],uuu[1],sep = "-"))
   fit <- eBayes(fit)
  contrast.names<-c(paste(uu[1],uu[2],sep = "v"),paste(uu[2],uu[1],sep = "v"))
  #write.csv(contrast.names,"contrasts.csv")
  
    # cont.matrix <- makeContrasts(contrasts = contrasts,levels=design)
    # contrast.fit <- contrasts.fit(fit, cont.matrix)
    # contrast.fit <- eBayes(contrast.fit, trend = TRUE)
    #results<-decideTests(contrast.fit, method = "separate", adjust.method = "BH", p.value = 0.05, lfc = 0.5)
    results<-decideTests(fit, method = "separate", adjust.method = "BH", p.value = 0.05, lfc = 0.5)
    colnames(results)<-contrast.names[2]
  })

  
  
}

if (opt$model == "Common Reference"){
  try({
  targets <- data.frame(lapply(targets, as.character), stringsAsFactors=FALSE)
  
  targets2<-targets
  targets2[,2]<- paste0("(",targets2[,2],")")
  targets2[,3]<- paste0("(",targets2[,3],")")

  targets3<-targets2
  targets3[,2]<-make.names(targets2[,2],unique = FALSE, allow_ = TRUE)
  targets3[,3]<-make.names(targets2[,3],unique = FALSE, allow_ = TRUE)

  uu<-unique(targets2[,2])
  uuu1<-unique(targets3[,2])
  uuu2<-unique(targets3[,3]) #confirm reference column
  design <- modelMatrix(targets3, ref = uuu2)
  fit <- lmFit(MA.summarized, design)

  f <- factor(targets3[,2], levels=unique(uuu1)) #confirm non reference column

  ######## Create Contrast Model
  combos<-combn(levels(f),2) # generate matrix of pairwise group combinations for comparison
  ff <- factor(targets2[,2], levels=unique(uu))
  combos.names<-combn(levels(ff),2)
  contrasts<-c(paste(combos[1,],combos[2,],sep = "-"),paste(combos[2,],combos[1,],sep = "-")) # format combinations for limma:makeContrasts
  contrast.names <-c(paste(combos.names[1,],combos.names[2,],sep = "v"),paste(combos.names[2,],combos.names[1,],sep = "v")) # format combinations for output table file names
  
  
  cont.matrix <- makeContrasts(contrasts = contrasts,levels=design)
  contrast.fit <- contrasts.fit(fit, cont.matrix)
  contrast.fit <- eBayes(contrast.fit)
  results<-decideTests(contrast.fit, method = "separate", adjust.method = "BH", p.value = 0.05, lfc = 0.5) # FDR .05

  })
}

if (opt$model == "Separate Channels"){
  try({
    targets$t2 <- targetsA2C(targets$t2, channel.codes = c(1,2), channel.columns = list(Target=c("Cy3","Cy5")),grep = FALSE)
    targets$t3 <- targetsA2C(targets$t3, channel.codes = c(1,2), channel.columns = list(Target=c("Cy3","Cy5")),grep = FALSE)

    uuu <- unique(targets$t3$Target)
    uu <- unique(targets$t2$Target)
    fff <- factor(targets$t3$Target, levels=uuu)
    design <- model.matrix(~0+fff)
    colnames(design) <- uuu
    corfit <- intraspotCorrelation(MA.summarized, design)
    fit <- lmscFit(MA.summarized, design, correlation=corfit$consensus)
    if (opt$filter_nonexpressed){
    
    CutOff <- quantile(fit$Amean,probs=.33)

    hist_res <- graphics::hist(as.matrix(fit$coefficients), 100, col = "cornsilk", freq = FALSE, 
            main = "Probe Filtering Intensity Cutoff",
            border = "antiquewhite4",
            xlab = "Median intensities")

    abline(v = CutOff, col = "coral4", lwd = 2)

    keep <- fit$Amean > CutOff
    fit <- fit[keep,] # filter out probes below cutoff expression level
    annotation.subset <- annotation.subset[keep,]
    }
    
    ######## Create Contrast Model
    combos<-combn(levels(fff),2) # generate matrix of pairwise group combinations for comparison
    uu <- unique(targets$t2$Target)
    ff <- factor(targets$t2$Target, levels=uu)
    combos.names<-combn(levels(ff),2)
    contrasts<-c(paste(combos[1,],combos[2,],sep = "-"),paste(combos[2,],combos[1,],sep = "-")) # format combinations for limma:makeContrasts
    contrast.names <-c(paste(combos.names[1,],combos.names[2,],sep = "v"),paste(combos.names[2,],combos.names[1,],sep = "v")) # format combinations for output table file names
    cont.matrix <- makeContrasts(contrasts = contrasts,levels=design)
    contrast.fit <- contrasts.fit(fit, cont.matrix)
    contrast.fit <- eBayes(contrast.fit, trend = TRUE)
    results<-decideTests(contrast.fit, method = "separate", adjust.method = "BH", p.value = 0.05, lfc = 0.5)
    
  })
}

try({
  colnames(results@.Data) <- contrast.names
  summary <- as.data.frame(summary(results))
  summary <- summary[,c(2,1,3)]
  colnames(summary)<-c("CONTRAST","REGULATION","GENE COUNT SIG")
  DT::datatable(summary, caption = "Summary of Differentially Regulated Genes (P<=05)")
})
```



```{r dge_tables, eval=exists("results"), message=FALSE, warning=FALSE}
### Generate DGE Output Files

dir.create(file.path(workdir,"Processed_Data",opt$glds,"02-Limma_DGE"), showWarnings = FALSE)
setwd(file.path(workdir,"Processed_Data",opt$glds,"02-Limma_DGE"))

########## Construct Output Data Tables
# output_table <- annotation.subset[,-c(1)]
# reduced_output_table <- annotation.subset[,-c(1)]
output_table <- annotation.subset
reduced_output_table <- annotation.subset

output_table$All.mean <- fit$Amean
reduced_output_table$All.mean <- fit$Amean

output_table$All.stdev <- fit$s2.post
reduced_output_table$All.stdev <- fit$s2.post

output_table$F.p.value <- fit$F.p.value
reduced_output_table$F.p.value <- fit$F.p.value

if (opt$model == "Replicate Array"){
  uu<-uu[1]
########## Add Group Mean Values
group_means<-as.data.frame(fit$coefficients)
colnames(group_means)<-paste0("Group.Mean_",uu)
output_table<-cbind(output_table,group_means)
reduced_output_table<-cbind(reduced_output_table,group_means)
rm(group_means)

# add group stdev columns
group_stdev<-as.data.frame(fit$stdev.unscaled * fit$coefficients)
colnames(group_stdev)<-paste0("Group.Stdev_",uu)
output_table<-cbind(output_table,group_stdev)
reduced_output_table<-cbind(reduced_output_table,group_stdev)
rm(group_stdev)  
  
}


if (opt$model == "Replicate Array"){
  # Contrast 1
  top <- topTable(fit, coef = 1, number = Inf, genelist = fit$genes$ID, adjust.method = "BH", sort.by = "none")
  table <- top[,c(2,5,6)] # Pull columns for Log2fc, P.value, Adj.p.value
  colnames(table)<- c("Log2fc","P.value","Adj.p.value")
  table.reduced <- table
  table$Updown <- sign(top$logFC)
  table$Sig.1 <- top$adj.P.Val<=0.1
  table$Sig.05 <- top$adj.P.Val<=0.05
  table$Log2_P.value <- log2(top$P.Value) # For volcano plot
  table$Log2_Adj.p.value <- log2(top$adj.P.Val) # For volcano plot
  colnames(table.reduced)<-paste(colnames(table.reduced),contrast.names[1],sep = "_")
  colnames(table)<-paste(colnames(table),contrast.names[1],sep = "_")
  output_table<-cbind(output_table,table)
  reduced_output_table<-cbind(reduced_output_table,table.reduced)
  
  # Repeat for contrast 2
  table <- top[,c(2,5,6)] # Pull columns for Log2fc, P.value, Adj.p.value
  colnames(table)<- c("Log2fc","P.value","Adj.p.value")
  table$Log2fc <- -1*table$Log2fc
  table.reduced <- table
  table$Updown <- sign(table$Log2fc)
  table$Sig.1 <- top$adj.P.Val<=0.1
  table$Sig.05 <- top$adj.P.Val<=0.05
  table$Log2_P.value <- log2(top$P.Value) # For volcano plot
  table$Log2_Adj.p.value <- log2(top$adj.P.Val) # For volcano plot
  
  colnames(table.reduced)<-paste(colnames(table.reduced),contrast.names[2],sep = "_")
  colnames(table)<-paste(colnames(table),contrast.names[2],sep = "_")
  output_table<-cbind(output_table,table)
  reduced_output_table<-cbind(reduced_output_table,table.reduced)
}

if (opt$model == "Separate Channels" || opt$model == "Common Reference"){

# iterate through contrasts
for (i in 1:length(contrasts)){
  top <- topTable(contrast.fit, coef = i, number = Inf, genelist = contrast.fit$genes$ID, adjust.method = "BH", sort.by = "none")
  table <- top[,c(2,5,6)] # Pull columns for Log2fc, P.value, Adj.p.value
  colnames(table)<- c("Log2fc","P.value","Adj.p.value")
  table.reduced <- table
  table$Updown <- sign(top$logFC)
  table$Sig.1 <- top$adj.P.Val<=0.1
  table$Sig.05 <- top$adj.P.Val<=0.05
  table$Log2_P.value <- log2(top$P.Value) # For volcano plot
  table$Log2_Adj.p.value <- log2(top$adj.P.Val) # For volcano plot
  
  colnames(table.reduced)<-paste(colnames(table.reduced),contrast.names[i],sep = "_")
  colnames(table)<-paste(colnames(table),contrast.names[i],sep = "_")
  output_table<-cbind(output_table,table)
  reduced_output_table<-cbind(reduced_output_table,table.reduced)
  }
rm(i,top,table,table.reduced)
}

########## Export DGE Output Data Tables


write.csv(reduced_output_table,"differential_expression.csv", row.names = FALSE)
write.csv(output_table,"visualization_output_table.csv", row.names = FALSE)


if (opt$model == "Replicate Array"){
  contrast.names<-c(paste(uu[1],uu[2],sep = "v"),paste(uu[2],uu[1],sep = "v"))
  write.csv(contrast.names,"contrasts.csv")
} else {
  contrast.output <- contrast.fit$contrasts
  row.names(contrast.output)<-uu
  colnames(contrast.output)<-contrast.names
  write.csv(contrast.output,"contrasts.csv")
}

### Export Metadata files
dir.create(file.path(workdir,"Processed_Data",opt$glds,"Metadata"), showWarnings = FALSE)
path<-file.path(workdir,"Processed_Data",opt$glds,"Metadata")
setwd(path)
file.copy(from = opt$isafile$datapath, to = file.path(path,opt$isafile$name),overwrite = FALSE, recursive = FALSE, copy.mode = FALSE)
try(file.copy(from = opt$probefile$datapath, to = file.path(path,opt$probefile$name),overwrite = FALSE, recursive = FALSE, copy.mode = FALSE))

cat("All data files have been written to:  ",file.path(workdir,"Processed_Data"))

```

```{r}
sessionInfo()
```

