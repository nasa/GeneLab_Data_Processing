---
title: "Differential Gene Expression Analysis"
output:
  html_document:
    pandoc_args: ["+RTS", "-K1024m", "-RTS"]

params:
  cpus: 1
  work_dir: "." # directory where the script will run
  output_directory: "." # directory for output files
  output_filename_label: "" # label for output file names
  output_filename_suffix: "" # suffix for output file names
  runsheet_path: NULL # path to the runsheet file
  input_counts: NULL # directory containing RSEM gene results OR FeatureCounts table for microbes mode
  gene_id_type: "" # denotes the name of the identifier column (e.g. ENSEMBL, TAIR)
  microbes: FALSE # set this to TRUE to use Bowtie 2 input
  DEBUG_MODE_LIMIT_GENES: FALSE # debugging option to limit the number of genes
  DEBUG_MODE_ADD_DUMMY_COUNTS: FALSE # debugging option to add dummy counts
  parallel_config: NULL # parallel configuration string (e.g. "MulticoreParam(workers = params$cpus)")
---

## Substeps {.tabset}

### 1. Setup<!---  START:NON_DPPD --->
```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir = params$work_dir)
```

### 2. Load Libraries and Parameters
```{r library-loading}
options(timeout=1200)
# List of required packages
cran_packages <- c("stringr", "knitr", "yaml", "dplyr")
bioc_packages <- c("tximport", "DESeq2", "BiocParallel")
# Install missing CRAN packages
for (pkg in cran_packages) {
    if (!require(pkg, character.only = TRUE)) {
        install.packages(pkg)
        library(pkg, character.only = TRUE)
    }
}
# Install BiocManager if not already installed
if (!require("BiocManager", character.only = TRUE)) {
    install.packages("BiocManager")
    library(BiocManager)
}
# Install missing Bioconductor packages
for (pkg in bioc_packages) {
    if (!require(pkg, character.only = TRUE)) {
        BiocManager::install(pkg)
        library(pkg, character.only = TRUE)
    }
}
# Load all required libraries
library(stringr)
library(knitr)
library(yaml)
library(dplyr)
library(tximport)
library(DESeq2)
library(BiocParallel)
# Set up parallel backend if params$parallel_config is defined, otherwise set BPPARAM <- SerialParam()
# See https://rdrr.io/bioc/BiocParallel/man/register.html
if (!is.null(params$parallel_config) && params$parallel_config != "") {
    BPPARAM <- eval(parse(text = params$parallel_config))
} else {
    BPPARAM <- SerialParam()
}
# Save parameters
yaml::write_yaml(params, file.path(params$output_directory, "last_params.yml"))
```

### 3. Load Study Metadata
```{r runsheet-to-compare_df}
compare_csv_from_runsheet <- function(runsheet_path) {
    df <- read.csv(runsheet_path)
    factors <- df %>%
        select(matches("Factor.Value", ignore.case = TRUE)) %>%
        rename_with(~ paste0("factor_", seq_along(.)))
    result <- df %>%
        select(sample_id = Sample.Name) %>%
        bind_cols(factors)
    return(result)
}
# Loading metadata from runsheet csv file
compare_csv <- compare_csv_from_runsheet(params$runsheet_path)
```

```{r compare_df-to-study_df}
study <- compare_csv[, -1, drop=FALSE]  # Exclude sample_id
rownames(study) <- compare_csv$sample_id
```

```{r study_df-to-group_df}
##### Format groups and indicate the group that each sample belongs to #####
group <- if (ncol(study) >= 2) {
    apply(study, 1, paste, collapse = " & ")
} else {
    study[[1]]
}
group_names <- paste0("(", group, ")")
group <- sub("^BLOCKER_", "", make.names(paste0("BLOCKER_", group)))
names(group) <- group_names
```

```{r group_df-to-contrasts_df}
##### Format contrasts table, defining pairwise comparisons for all groups #####
contrast.names <- combn(levels(factor(names(group))),2) # generate matrix of pairwise group combinations for comparison
contrasts <- apply(contrast.names, MARGIN=2, function(col) sub("^BLOCKER_", "",  make.names(paste0("BLOCKER_", stringr::str_sub(col, 2, -2)))))
contrast.names <- c(paste(contrast.names[1,],contrast.names[2,],sep = "v"),paste(contrast.names[2,],contrast.names[1,],sep = "v")) # format combinations for output table files names
contrasts <- cbind(contrasts,contrasts[c(2,1),])
colnames(contrasts) <- contrast.names
rm(contrast.names)
```

### 4. Load Gene Counts
```{r load-gene-counts}
##### Import FeatureCounts or RSEM count data #####
if (params$microbes) {
    # For microbes, look for FeatureCounts TSV file
    if (!file.exists(params$input_counts)) {
        stop(paste("FeatureCounts file not found at:", params$input_counts))
    }
    # Load featureCounts data with tab separator
    featurecounts <- read.csv(params$input_counts, header = TRUE, sep = "\t", skip = 1, check.names = FALSE)
    # Create counts matrix: remove metadata columns, remove possible .bam from column names
    row.names(featurecounts) <- featurecounts$Geneid
    counts <- featurecounts[,-c(1:6)]
    colnames(counts) <- gsub("\\.bam$", "", colnames(counts))
    # Reorder counts columns to match runsheet
    counts <- counts[, rownames(study)]
} else {
    # Load RSEM data for default mode
    files <- list.files(
        path = params$input_counts, 
        pattern = ".genes.results$", 
        full.names = TRUE
    )

    # Remove "_rRNArm" from filenames for matching
    clean_filenames <- sub("_rRNArm", "", basename(files))

    samples <- rownames(study)

    # Reorder files based on sample names
    reordering <- sapply(samples, function(x) {
        grep(paste0("^", x, "\\.genes.results$"), clean_filenames, value = FALSE)
    })

    files <- files[reordering]
    names(files) <- samples

    # Import data using tximport
    txi.rsem <- tximport(files, type = "rsem", txIn = FALSE, txOut = FALSE)

    if (dim(txi.rsem$counts)[2] != nrow(study)) {
        stop("Sample count mismatch between imported gene results and runsheet")
    }
}
##### Apply debug options if enabled #####
if (params$DEBUG_MODE_LIMIT_GENES) {
    if (params$microbes) {
        counts <- counts[1:150,]
    } else {
        txi.rsem$counts <- txi.rsem$counts[1:150,]
    }
    print(sprintf("DEBUG: %s: Limiting analysis to first 150 genes", Sys.time()))
}
if (params$DEBUG_MODE_ADD_DUMMY_COUNTS) {
    set.seed(1)
    if (params$microbes) {
        counts <- counts + matrix(
            sample(0:5000, NROW(counts)*NCOL(counts), replace=TRUE),
            nrow=NROW(counts)
        )
    } else {
        txi.rsem$counts <- txi.rsem$counts + matrix(
            sample(0:5000, NROW(txi.rsem$counts)*NCOL(txi.rsem$counts), replace=TRUE),
            nrow=NROW(txi.rsem$counts)
        )
    }
    print(sprintf("DEBUG: %s: Replacing original counts with random values from 0 to 5000", Sys.time()))
}

# Save a copy of the original counts before any filtering
if (params$microbes) {
    original_counts <- counts
} else {
    original_txi_counts <- txi.rsem$counts
}

if (params$microbes) {
} else {
    ## Add 1 to genes with lengths of zero - needed to make DESeqDataSet object
    print(sprintf("DEBUG: %s: Converting %d zero length genes to 1-length of %d genes (%f %% total)", Sys.time(), length(txi.rsem$length[txi.rsem$length == 0]), length(txi.rsem$length), length(txi.rsem$length[txi.rsem$length == 0])/length(txi.rsem$length)))
    txi.rsem$length[txi.rsem$length == 0] <- 1
}
```

```{r create-sample-table}
## Create data frame defining which group each sample belongs to
sampleTable <- data.frame(condition=factor(group))
rownames(sampleTable) <- if (params$microbes) {
    colnames(counts)
} else {
    colnames(txi.rsem$counts)
}
# Handle technical replicates
# Identify technical replicates by name pattern
tech_rep_pattern <- "_techrep(\\d+)$"
all_samples <- rownames(sampleTable)
has_tech_rep <- grepl(tech_rep_pattern, all_samples)

# Only process if we have technical replicates
if (any(has_tech_rep)) {
    # Get sample base names and tech replicate numbers
    sample_info <- data.frame(
        name = all_samples,
        stringsAsFactors = FALSE
    )
    
    # For samples with tech reps, extract base name and replicate number
    sample_info$base_name <- ifelse(has_tech_rep, 
                                   sub(tech_rep_pattern, "", all_samples),
                                   all_samples)
    
    sample_info$tech_rep <- rep(1, length(all_samples))
    sample_info$tech_rep[has_tech_rep] <- as.integer(sub(".*_techrep", "", all_samples[has_tech_rep]))
    
    # Count how many tech reps each base sample has
    base_samples <- unique(sample_info$base_name)
    tech_rep_counts <- sapply(base_samples, function(b) {
        sum(sample_info$base_name == b)
    })
    
    # Find the minimum number of tech reps across all samples
    min_tech_reps <- min(tech_rep_counts)
    
    # Keep all regular samples (no tech reps) and the minimum number of tech reps for each base sample
    samples_to_keep <- character(0)
    
    for (base in base_samples) {
        indices <- which(sample_info$base_name == base)
        if (length(indices) == 1) {
            # Regular sample, no tech reps
            samples_to_keep <- c(samples_to_keep, sample_info$name[indices])
        } else {
            # Has tech reps, keep the minimum number in order
            ordered_indices <- indices[order(sample_info$tech_rep[indices])]
            samples_to_keep <- c(samples_to_keep, sample_info$name[ordered_indices[1:min_tech_reps]])
        }
    }
    
    # Update sample table and counts to keep only selected samples
    sampleTable <- sampleTable[samples_to_keep, , drop=FALSE]
    
    # Update the counts matrix to match the new sample table
    if (params$microbes) {
        counts <- counts[, samples_to_keep]
    } else {
        txi.rsem$counts <- txi.rsem$counts[, samples_to_keep]
        txi.rsem$abundance <- txi.rsem$abundance[, samples_to_keep]
        txi.rsem$length <- txi.rsem$length[, samples_to_keep]
    }
}
```

### 4. DGE
```{r load-deseq2-dataset}
# Create dataset
if (params$microbes) {
    # Build DESeqDataSet directly from counts for microbes mode
    dds <- DESeqDataSetFromMatrix(
        countData = counts,
        colData = sampleTable,
        design = ~condition
    )
} else {
    # Build DESeqDataSet from tximport object for non-microbes mode
    dds <- DESeqDataSetFromTximport(
        txi = txi.rsem,
        colData = sampleTable,
        design = ~condition
    )
}
# Collapse technical replicates if present
if (any(grepl("_techrep\\d+$", rownames(sampleTable)))) {
    tech_rep_groups <- sub("_techrep\\d+$", "", rownames(sampleTable))
    dds <- collapseReplicates(dds, tech_rep_groups)
}
summary(dds)
```

```{r filter-genes-by-normalized-counts}
##### Filter out genes with counts of less than 10 in all samples #####
keep <- rowSums(counts(dds)) > 10
print(sprintf("DEBUG: %s: Removed %d genes for having dataset wide count sum less than 10. (%f%% of all genes)", Sys.time(), sum(!keep), sum(!keep)/length(keep)*100))
dds <- dds[keep,]
summary(dds)
dim(dds)
```

```{r default-normalized-dge-analysis}
# remove ERCC genes if any are present
if (length(grep("ERCC-", rownames(dds))) != 0) {
    dds <- dds[-c(grep("ERCC-", rownames(dds))), ]
}
dds <- DESeq(dds, parallel = TRUE, BPPARAM = BPPARAM)
```

```{r output-counts-related-files}
normCounts <- as.data.frame(counts(dds, normalized = TRUE))
VSTCounts <- as.data.frame(assay(vst(dds)))
write.csv(
    if (params$microbes) {
        original_counts
    } else {
        original_txi_counts
    },
    file = file.path(params$output_directory,
                     paste0(if(params$microbes) "FeatureCounts_Unnormalized_Counts" 
                           else "RSEM_Unnormalized_Counts",
                           params$output_filename_label, params$output_filename_suffix, ".csv"))
)
write.csv(
    normCounts,
    file = file.path(params$output_directory,
                     paste0("Normalized_Counts",
                           params$output_filename_label, params$output_filename_suffix, ".csv"))
)
write.csv(
    VSTCounts,
    file = file.path(params$output_directory,
                     paste0("VST_Counts",
                           params$output_filename_label, params$output_filename_suffix, ".csv"))
)
```

```{r prep-counts-for-dge}
## Add 1 to all counts to avoid issues with log transformation
normCounts <- normCounts + 1
## output table 1 will be used to generate computer-readable DGE table,
## which is used to create GeneLab visualization plots
output_table <- tibble::rownames_to_column(normCounts, var = params$gene_id_type)
```

```{r run-deseq2-LRT}
##### Generate F statistic p-value (similar to ANOVA p-value) using DESeq2 likelihood ratio test (LRT) design #####
print(sprintf("DEBUG: %s: Generating Likelihood Ratio Test Based Statistics", Sys.time()))
dds_lrt <- DESeq(dds, test = "LRT", reduced = ~1)
res_lrt <- results(dds_lrt)
# Store LRT p-value (add after means and stdevs)
lrt_pvalues <- res_lrt@listData$padj
```

```{r wald-test-iteration}
## Iterate through Wald Tests to generate pairwise comparisons of all groups
compute_contrast <- function(dds, i) {
    res <- results(
        dds,
        contrast = c("condition", contrasts[1, i], contrasts[2, i]),
        parallel = FALSE  # Disable internal parallelization
    )
    res_df <- as.data.frame(res@listData)[, c(2, 4, 5, 6)]
    colnames(res_df) <- c(
        paste0("Log2fc_", colnames(contrasts)[i]),
        paste0("Stat_", colnames(contrasts)[i]),
        paste0("P.value_", colnames(contrasts)[i]),
        paste0("Adj.p.value_", colnames(contrasts)[i])
    )
    return(res_df)
}
res_list <- bplapply(1:dim(contrasts)[2], function(i) compute_contrast(dds, i), BPPARAM = BPPARAM)
# Combine the list of data frames into a single data frame
res_df <- do.call(cbind, res_list)
# Combine with the existing output_table
output_table <- cbind(output_table, res_df)
```

```{r calculate-group-statistics}
### Add summary statistics ###
output_table$All.mean <- rowMeans(normCounts, na.rm = TRUE)
output_table$All.stdev <- matrixStats::rowSds(as.matrix(normCounts), na.rm = TRUE, useNames = FALSE)
output_table$LRT.p.value <- res_lrt@listData$padj
# Calculate group means and standard deviations
tcounts <- as.data.frame(t(normCounts))
# Assign group labels based on `sampleTable`
tcounts$group <- sampleTable$condition[match(rownames(tcounts), rownames(sampleTable))]
# Aggregate group means and standard deviations
agg_means <- aggregate(. ~ group, data = tcounts, FUN = mean, na.rm = TRUE)
agg_stdev <- aggregate(. ~ group, data = tcounts, FUN = sd, na.rm = TRUE)
# Extract group names
group_ids <- agg_means$group
# Remove the 'group' column and transpose to match expected structure
group_means <- as.data.frame(t(agg_means[-1]))
group_stdev <- as.data.frame(t(agg_stdev[-1]))
# Get cleaned group names
orig_group_names <- group_names[match(group_ids, group)]
# Interleave means and stdevs for each group
group_stats <- data.frame(matrix(ncol = 0, nrow = nrow(group_means)))
for (i in seq_along(group_ids)) {
    # Create column names with cleaned group names
    mean_colname <- paste0("Group.Mean_", orig_group_names[i])
    stdev_colname <- paste0("Group.Stdev_", orig_group_names[i])
    # Add columns
    group_stats[[mean_colname]] <- group_means[,i]
    group_stats[[stdev_colname]] <- group_stdev[,i]
}
### Add computed group means and standard deviations to output_table ###
output_table <- cbind(output_table, group_stats)
```

```{r output-dge-related-files}
# note: the paste0 here is ensure no string file name prefixes still create their directories
# e.g. dge_output/
dir.create(dirname(paste0(params$output_directory)), recursive = TRUE)
write.csv(
    contrasts,
    file = file.path(params$output_directory, 
                     paste0("contrasts", params$output_filename_label, params$output_filename_suffix, ".csv"))
)
write.csv(
    output_table,
    row.names = FALSE,
    file = file.path(params$output_directory, 
                     paste0("differential_expression_no_annotations", params$output_filename_label, params$output_filename_suffix, ".csv"))
)
write.csv(
    sampleTable,
    file = file.path(params$output_directory, 
                     paste0("SampleTable", params$output_filename_label, params$output_filename_suffix, ".csv"))
)
# Create summary file based on output_table
output <- capture.output(summary(output_table))
# Write summary file
conn <- file(file.path(params$output_directory, "summary.txt"), "w")
writeLines(output, conn)
close(conn)
```

```{r version-reporting}
## print session info ##
session_info_output <- capture.output(sessionInfo())
# Write versions file
cat(session_info_output,
    "BioC_version_associated_with_R_version",
    toString(BiocManager::version()),
    file = file.path(params$output_directory, "versions.txt"),
    append = TRUE,
    sep = "\n")
```